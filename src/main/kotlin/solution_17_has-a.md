1. Возьмем сущность `EncryptedMessage`, представляющую собой зашифрованное текстовое сообщение в мессенджере. Внешне похоже, что сущность "является" типом `Message`, но в действительности `EncryptedMessage` содержит и экземпляр `Message`, и алгоритм шифрования, который может динамически изменяться в процессе работы программы.
2. Обратимся к примеру со средством передвижения. Есть тип Vehicle с базовыми атрибутами, не относящимися к к характеристикам специфичного транспортного средства. Например, цвет и вес. И есть тип HybridVehicle, которое умеет ездить и плавать или летать и ездить. Выглядит, что HybridVehicle "является" подтипом Vehicle со специфичным поведением. Однако если в проекте будут узкоспециализированные транспортные средства, то по-сути потребуется создавать дополнительную ветку в иерархии от типа Vehicle, что кажется признаком плохого проектирования, и создаст, вероятно, много дублирования в разных ветках иерархии. Так уместнее будет отношение "содержит", когда HybridVehicle содержит признаки и машины, и лодки, и чего-то летающего. Это позволит не ограничиваться жесткой иерархией наследования при расширении транспортных средств и гибче вносить правки.  