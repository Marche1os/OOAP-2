**Первый пример**

Представим, что есть Android приложение, которое должно делиться данными с другими приложениями. В таком случае мы должны создать сущность, которая будет являться поставщиком данных (ContentProvider). Назовем ее `MyContentProvider`.

В данном случае, `MyContentProvider` "является" ContentProvider-ом, потому что он наследует все его интерфейсы и поведение, но также реализует специфичный контент и логику доступа к данным, которые отличают его от других поставщиков контента.

Применение отношения "содержит" в этом случае было бы неправильным, поскольку поставщик контента нашего приложения не просто использует ContentProvider как часть своей функциональности, а он полностью интегрирует интерфейс и контракты ContentProvider-а, расширяя их для предоставления контента. Следовательно, наш MyContentProvider не может содержать ContentProvider, так как он сам реализует абстракцию ContentProvider. И это относится ко всем стандартным поставщикам контента (DocumentContentProvider, FileContentProvider, ...)


**Второй пример**

Смоделируем пример из реального мира.

Класс "Фура" "является" потомком класса "Автомобиль". Фура обладает всеми характеристиками автомобиля, но также имеет дополнительные атрибуты и поведение, характерные для нее. Например, работа с прицепом. Фуру нельзя считать композицией автомобиля, так как она не "содержит" автомобиль, а сама является автомобилем.
