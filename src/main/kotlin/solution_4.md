Допустим у нас есть маркетплейс и иерархия классов, описывающая виды доставки. Базовым, фундаментальным абстрактным классом будет класс Delivery. 
Этот класс выбран закрытым, так как содержит фундаментальную для всех остальных видов доставки логику и обязан следовать контракту, согласно которому запрещено вносить в производственной среде изменения, влияющие на дочерние классы. Кроме того он предоставляет интерфейс для работы с конкретными видами доставки.

Наследниками класса Delivery будут открытые к изменениям классы _OnDemandDelivery_, _PvzDelivery_, _CourierDelivery_. 
Эти классы будут открытыми к изменениям и в целом при разработке нового функционала, касающегося сущнствующих видов доставки, будут заложены в эти классы. Например, CourierDelivery можно будет расширить новыми курьерскими опциями доставки, например, подъемом на этаж.

Такой подход позволит добавлять новые виды доставки, не затрагивая существующий код. Базовый закрытый класс Delivery редко нуждается в модификации, а наследники этого класса являются открытыми для расширения и адаптации под новые требования без вмешательства в уже существующий код.